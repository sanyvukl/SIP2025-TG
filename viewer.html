<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tournaments</title>
<style>
  :root{
    --bg:#0b1016;
    --ink:#e6edf7;
    --muted:#9aa3b2;
    --panel:#0f141a;
    --ring:#263043;
    --focus:#3b82f6;
    --good:#19c37d;
    --warn:#f59e0b;
    --bad:#ef4444;
    --chip:#151a20;

        /* brand + surfaces */
    --bg:#121419;
    --panel:#20242c;
    --ring:#2b3140;
    --focus:#3b82f6;

    /* text */
    --ink:#e9edf4;
    --muted:#9aa3b2;

    /* states */
    --ok:#22c55e;
    --err:#ef4444;

    /* bracket specifics */
    --slot-bg:#3a3f48;     /* row background */
    --seed-bg:#4a4f58;     /* brighter than slot */
    --score-bg:#2d3139;    /* score box */
    --score-win:#ff6a2f;   /* winner highlight */
  }
  html,body{margin:0;padding:0;
    background:var(--bg);
    color:white;
    font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,"Noto Sans",sans-serif; font-weight: 400;}
  
  h1,h2,h3,h4,h5,h6,p,div{
    color: white;
  }
  span{
    color: var(--ink);
  }
  .tournament-name{
    color: white;
  }
  .scale-5{
    transform: scale(1.05);
  }
  .scale-10{
    transform: scale(1.10);
  }
  .scale-15{
    transform: scale(1.15);
  }
  .scale-20{
    transform: scale(1.20);
  }
  .scale-25{
    transform: scale(1.25);
  }

  .wrap{max-width:1200px; min-width: 900px;margin:22px auto;padding:0 12px;}
  .card{
    background: rgba(24, 28, 35, 0.7);
    backdrop-filter: blur(10px) saturate(120%);
    border: 1px solid rgba(70, 80, 95, 0.3);
    box-shadow:
      0 8px 30px rgba(0, 0, 0, 0.4),
      inset 0 1px 0 rgba(255, 255, 255, 0.05);
    border-radius: 18px;
    padding:16px
  }
  .head{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
  .tools{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{appearance:none;border:1px solid var(--ring);background:#101621;color:white;padding:8px 12px;border-radius:8px;cursor:pointer; font-size: 16px;}
  .btn[disabled]{opacity:.55;cursor:not-allowed}
  .btn.ghost{background:#161b23}
  .list .row{display:flex;justify-content:space-between;align-items:center;background:#191d24;border:1px solid var(--ring);border-radius:10px;padding:10px 14px;margin-bottom:8px}
  .row .left{display:flex;align-items:center;gap:24px; margin-right: 100px;}
  .bits{display:flex;gap:16px;flex-wrap:wrap;color:#ccc}
  .muted{color:var(--muted)}
  .pager{display:flex;gap:8px;align-items:center;margin-top:10px;flex-wrap:wrap}
  .k{font-size:12px;color:var(--muted)}
  .chip{background:var(--chip);border:1px solid var(--ring);border-radius:999px;padding:2px 8px;font-size:12px}
  /* Modal */
  .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;z-index:30}
  .modal{width:min(1100px,95vw);max-height:76vh;background:rgba(24, 28, 35, 1);border:1px solid var(--ring);border-radius:12px;overflow:hidden;display:flex;flex-direction:column}
  .modal-backdrop.show{display:flex}
  .modal-h{
    display:flex;
    flex-direction: column;
    padding:12px;
    border-bottom:1px solid var(--ring);
    gap:8px
  }
  .title-row .title{font-weight:700; font-size: 20px;}
  .title-row{
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 10px;
  }
  .details-row{
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .details-row .format{
    font-size: 14px;
    color: #eee;
  }
  .details-row .players{
    font-size: 14px;
    color: #eee;
  }
  .details-row .game-to{
    font-size: 14px;
    color: #eee;
  }
  .status-box{
    display:flex;
    flex-direction: row;
    gap: 8px;
  }
  .status .status-indicator{
    color: #e02b2a;
    padding-left: 5px;
  }
  .status-box div{
    gap:8px; max-width: max-content;
    appearance:none;border:1px solid var(--ring);
    background:#0f141a;color:var(--ink);
    padding:8px 10px;border-radius:8px;
  }
  .tabs{display:flex;gap:8px; max-width: max-content;}
  .tab{appearance:none;border:1px solid var(--ring);background:#0f141a;color:var(--ink);padding:8px 10px;border-radius:8px;cursor:pointer; font-size: 16px;}
  .tab.active{outline:2px solid white;outline-offset:1px;background:#132032}
  .modal-b{padding:12px;overflow:auto}
  /* Players list */
  .p-wrap{ border:1px solid var(--ring); border-radius:8px; background:#11161d; padding:12px }
  .p-row{
    display:flex; align-items:center; justify-content:space-between;
    background:#191d24; border:1px solid var(--ring); border-radius:8px;
    padding:10px 12px; margin-bottom:8px;
  }
  .p-row.alt{ background: var(--panel); } /* a bit brighter than normal */
  .p-seed{ font-size:12px; color:#cfd6e3; background:#4a4f58; border:1px solid var(--ring);
    min-width:28px; text-align:center; border-radius:6px; padding:2px 6px; margin-right:10px }
  .p-name{ flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
  /* Bracket shell */
  .section{margin-bottom:18px}
  .section-head{display:flex;align-items:center;justify-content:center;font-size:14px;color:#cfd6e3;text-transform:uppercase;letter-spacing:.04em;margin:0 0 10px 0}
  .grid-shell{border:1px solid var(--ring);border-radius:8px;background:#11161d;padding:14px;width:100%;overflow:auto;box-sizing:border-box}
  .round-head{font-size:14px;color:#9aa3b2;text-transform:uppercase;letter-spacing:.04em;margin:0 0 8px 0;text-align:center}
  .br-header{display:flex;gap:18px;align-items:baseline;background:#11161d;position:sticky;top:0;padding-top:2px;padding-bottom:6px}
  .br-head-cell{min-width:240px;flex:0 0 auto;text-align:center}
  .br-body{display:flex;gap:18px;align-items:stretch;padding-bottom:4px}
  .col{display:flex;flex-direction:column;flex:0 0 auto;width:240px; min-height: 100%;}
  .lane{display:flex;flex-direction:column;justify-content:space-around;gap:16px; height: 100%;}
  /* Match card */
  .mx{width:220px;border: 1px solid #FFFFFF24;;border-radius:4px;overflow:hidden;background:#22262d;display:grid;grid-template-rows:28px 28px auto;}
  .mx-slot{display:flex;align-items:stretch;justify-content:space-between;background:#3a3f48;font-size:13px;}
  .mx-slot + .mx-slot { border-top: 1px solid var(--ring); }  /* crisp divider */
  .mx-left{display:flex;align-items:center;flex:1;min-width:0}
  .mx-seed{background:#4a4f58;color:#cfd6e3;font-size:13px;font-weight:600;min-width:24px;padding:0 4px;text-align:center;display:flex;align-items:center;justify-content:center;height:100%;border-right:1px solid var(--ring)}
  .mx-name{flex:1;padding:0 8px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis; max-width: 138px; text-align: left;}
  .mx-score{display: flex; justify-content: center; align-items: center; height:100%; width:32px; margin:0; padding:0; border:none; border-left:1px solid var(--ring);
    text-align:center; font-weight:800; font-size:14px; background:var(--score-bg); color:#bfc6d1; align-self: center;}
  .mx-score.winner{ background:var(--score-win); color:#fff }
  .mx-actions{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:6px;background:#1b2027;border-top:1px solid var(--ring);font-size:11px}
  .badge{font-size:10px;padding:3px 6px;border-radius:6px;color:#cfd6e3;border:1px solid transparent}
  .badge.pending{background:#2a2f37;border-color:#3a404c}
  .badge.in_progress{background:#112036;border-color:#2a406b}
  .badge.completed{background:#0f2a17;border-color:#214b32}
  /* Finals card style */
  .mx.gfinal{background:linear-gradient(180deg,#3a2a10 0%,#1f1608 100%);border-color:#facc15;box-shadow:0 0 14px rgba(250,204,21,.6)}
  .mx.gfinal .mx-slot{color:#fff7e0}
  /* Rankings */
  table{border-collapse:collapse;width:100%}
  th,td{border-bottom:1px solid #202632;padding:8px 10px;text-align:left}
  .cell-last span{
    display: inline-block;
    padding: 2px 6px;
    border-radius: 6px;
  }
  .cell-last span.won{
    background: rgb(18, 48, 27);
    color: rgb(167, 243, 208);
    border: 1px solid rgb(31, 80, 48);
  }
  .cell-last span.lost{
    background: rgb(48, 18, 20);
    color: rgb(254, 202, 202);
    border: 1px solid rgb(90, 29, 34);
  }
  .cell-name-span{
    display: block;
    max-width: 310px;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis
  }
  th{font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:.04em}
  .right{float:right}
  /* Chips inline */
  .inline-chips{display:flex;gap:8px;flex-wrap:wrap}

  /* HTML: <div class="modal-loader"></div> */
  .modal-loader-wrapper{
    height: 400px;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .loader {
    width: 60px;
    aspect-ratio: 1;
    display: flex;
    animation: l10-0 2s infinite steps(1);
  }
  .loader::before,
  .loader::after {
    content: "";
    flex: 1;
    animation: 
      l10-1 1s infinite linear alternate,
      l10-2 2s infinite steps(1) -.5s;
  }
  .loader::after {
    --s:-1,-1;
  }
  @keyframes l10-0 {
    0%  {transform: scaleX(1)  rotate(0deg)}
    50% {transform: scaleX(-1) rotate(-90deg)}
  }
  @keyframes l10-1 {
    0%,
    5%   {transform:scale(var(--s,1)) translate(0px)   perspective(150px) rotateY(0deg) }
    33%  {transform:scale(var(--s,1)) translate(-10px) perspective(150px) rotateX(0deg) }
    66%  {transform:scale(var(--s,1)) translate(-10px) perspective(150px) rotateX(-180deg)}
    95%,
    100% {transform:scale(var(--s,1)) translate(0px)   perspective(150px) rotateX(-180deg)}
  }
  @keyframes l10-2 {
    0%  {background:#f9fafb;border-radius: 0}
    50% {background:#9ca3af;border-radius: 100px 0 0 100px}
  }
</style>
</head>
<body>
      <div class="wrap scale-5">
        <div class="card">
          <div class="head">
            <img width="120" src="https://cdn.prod.website-files.com/65f468704d1a4d5ffac8b9ce/667c55404e169290f9e94e53_Lockin.png" alt="Live Tournaments" srcset="">
            <div class="tools">
              <button class="btn" id="refreshBtn">Load</button>
            </div>
          </div>

          <div id="list" class="list" style="display: none;"></div>
          <div id="list-loader" class="modal-loader-wrapper" style="display: flex;">
            <div class="loader"></div>
          </div>
        </div>
      </div>

      <!-- Modal -->
      <div id="modal" class="modal-backdrop scale-5">
        <div class="modal">
          <div class="modal-h">
            <div class="title-row">
                <div class="title" id="mTitle">Tournament</div>
            </div>
            <div class="details-row">
              <div class="status-box">
                  <div class="status" id="mStatus">Live <span class="status-indicator">●</span></div>
                  <div class="format" id="mFormat">...</div>
                  <div class="game-to" id="mGameTo">...</div>
                  <div class="players" id="mPlayers">...</div>
              </div>
              <div class="tabs">
                <button class="tab active" data-tab="tournament">Tournament</button>
                <button class="tab" data-tab="ranking">Ranking</button>
                <button class="btn ghost" id="closeBtn">x</button>
              </div>
          </div>
            
          </div>
          <div class="modal-b">
            <div id="tabTournament" style="display:none">
              <div class="section">
                <div class="section-head">Winners Bracket</div>
                <div class="grid-shell">
                  <div class="br-header" id="wHead"></div>
                  <div class="br-body" id="wBody"></div>
                </div>
              </div>

              <div class="section" id="losersSection" style="display:none">
                <div class="section-head">Losers Bracket</div>
                <div class="grid-shell">
                  <div class="br-header" id="lHead"></div>
                  <div class="br-body" id="lBody"></div>
                </div>
              </div>
              
            </div>

            <div id="tabRanking" style="display:none">
              <div class="section">
                <div class="section-head">Standings</div>
                <div id="rkWrap" class="grid-shell" style="padding:0">
                  <table id="rkTable">
                    <thead>
                      <tr>
                        <th>#</th><th>Player</th><th>Seed</th><th>W</th><th>L</th><th>Win %</th>
                        <th>Frames</th><th>Diff</th><th>Elim</th><th>Last</th>
                      </tr>
                    </thead>
                    <tbody id="rkBody"></tbody>
                  </table>
                </div>
              </div>
            </div>

            <div id="modal-loader" class="modal-loader-wrapper" style="display:flex">
              <div class="loader"></div>
            </div>
          </div><!-- /modal-b -->
        </div>
      </div>
<script>
/* -------------------- CONFIG -------------------- */
const API_BASE = 'https://script.google.com/macros/s/AKfycbyo_iGxZfs3S_zirvFLbxuca6YxcNmFx-68qAYlAsQUfrioKzOduvWkq3ZiEVB2kyKMhA/exec'; 
const PAGE_SIZE = 100;

/* -------------------- UTIL -------------------- */
const $ = (q,root=document)=>root.querySelector(q);
const $$ = (q,root=document)=>Array.from(root.querySelectorAll(q));
const esc = (s)=>String(s==null?'':s)
  .replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
const fmtFormat = (raw)=> {
  const s = String(raw||'').toLowerCase();
  if (s==='double') return 'Double Elimination';
  if (s==='single') return 'Single Elimination';
  return raw || '—';
};
const fmtDate = (dt)=> {
  if (!dt) return '-';
  try{
    return new Date(dt).toLocaleString(undefined,{year:'numeric',month:'short',day:'numeric',hour:'2-digit',minute:'2-digit'});
  }catch{ return String(dt); }
};
const toForm = (obj)=> new URLSearchParams(obj);

/* -------------------- API -------------------- */
async function apiGet(params = {}) {
  const url = new URL(API_BASE);
  Object.entries(params).forEach(([k, v]) => url.searchParams.set(k, v));
  const res = await fetch(url); // simple GET, no headers
  if (!res.ok) throw new Error('Network error ' + res.status);
  const json = await res.json();
  if (json && json.ok === false) throw new Error(json.error || 'Server error');
  return json;
}

async function listTournaments({ status = 'active', page = 1, limit = PAGE_SIZE } = {}) {
  return apiGet({ action: 'listTournaments', status, page, limit });
}

async function listPlayers(tournament_id) {
  const j = await apiGet({ action: 'listPlayers', tournament_id });
  return j.players || [];
}

async function listMatches(tournament_id) {
  const j = await apiGet({ action: 'listMatches', tournament_id });
  return j.matches || [];
}

async function getRanking(tournament_id) {
  return apiGet({ action: 'getRanking', tournament_id });
}

/* -------------------- STATE -------------------- */
let currentPage = 1;
let meta = { page:1, pages:1, total:0, has_prev:false, has_next:false, race_to:0 };
let timer = null;

/* -------------------- LIST RENDER -------------------- */
function renderList(items){
  const root = $('#list');
  root.innerHTML = '';
  if (!items.length){
    const div = document.createElement('div');
    div.className='k';
    div.style.padding='6px 0';
    div.textContent = 'No active tournaments.';
    root.appendChild(div);
    return;
  }

  items.forEach(t=>{
    const row = document.createElement('div');
    row.className = 'row';

    const left = document.createElement('div');
    left.className = 'left';
    const name = document.createElement('span');
    name.className = 'tournament-name';
    name.style.fontWeight='700';
    name.style.fontSize='16px';
    name.textContent = t.name || '-';

    const bits = document.createElement('div');
    bits.className='bits';
    bits.innerHTML = `
      <span>${esc(fmtDate(t.start_time))}</span>
    `;

    left.appendChild(name);
    left.appendChild(bits);

    const right = document.createElement('div');
    right.style.display='flex';
    right.style.gap='8px';

    const btnView = document.createElement('button');
    btnView.className='btn';
    btnView.textContent='View';
    btnView.addEventListener('click', async (e)=> {
      e.preventDefault();
      e.stopPropagation();

      // kill any previous loop and blank the modal first
      CurrentTournamentRefresher.stop();
      resetModal();

      // if you don't have a valid id, never try to restore (prevents cache collision on 'undefined')
      if (!t.id) {
        openModal(t);
        return;
      }

      // If cached, show instantly (no flicker), then resume silent refresh
      if (restoreModal(t)) {
        const modal = $('#modal');
        modal.dataset.tid    = String(t.id);
        modal.dataset.format = String(t.format || 'single');
        modal.dataset.raceTo = String(t.race_to || '');
        meta.race_to = Number(modal.dataset.raceTo);

        // keep content fresh in background
        CurrentTournamentRefresher.start(t, 10000);
        // If Ranking tab is showing, refresh it silently
        if (activeTab() === 'ranking') {
          Ranking.refresh(String(t.id));
        }
        return;
      }

      // No cache → clear & do normal open (will show loader as needed)
      $('#wHead').innerHTML = $('#wBody').innerHTML = '';
      $('#lHead').innerHTML = $('#lBody').innerHTML = '';
      $('#rkBody').innerHTML = '';
      openModal(t);
    });
    
    right.appendChild(btnView);
    row.appendChild(left);
    row.appendChild(right);
    root.appendChild(row);
  });
}


/* -------------------- LOAD -------------------- */
async function load(page=1, { quiet = false } = {}){
  if (!quiet) setListLoading(true);
  $('#refreshBtn').disabled = true;
  $('#refreshBtn').textContent = 'Refreshing…';
  try{
    const data = await listTournaments({ status:'active', page, limit: PAGE_SIZE });
    renderList(data.tournaments||[]);
    meta = data.meta || meta;
    currentPage = meta.page || page;
    $('#refreshBtn').textContent = data.tournaments?.length ? 'Refresh' : 'Load';
  }catch(e){
    console.log('Failed to load active tournaments: ' + e.message);
    renderList([]);
    meta = { page:1,pages:1,total:0,has_prev:false,has_next:false };
    $('#refreshBtn').textContent = 'Load';
  }finally{
    $('#refreshBtn').disabled = false;
    if (!quiet) setListLoading(false);
  }
}

$('#refreshBtn').addEventListener('click', ()=>load(currentPage));

/* -------------------- LOADER HELPERS -------------------- */
function setListLoading(on){
  const list = $('#list');
  const spinner = $('#list-loader');
  if (!list || !spinner) return;
  spinner.style.display = on ? 'flex' : 'none';
  list.style.display    = on ? 'none' : '';
}

const activeTab = () => ($('.tab.active')?.dataset.tab || 'tournament');
function showTab(name){
  $('#tabTournament').style.display = (name === 'tournament') ? '' : 'none';
  $('#tabRanking').style.display   = (name === 'ranking')    ? '' : 'none';
}

function setModalLoading(on, { force = false } = {}){
  const sp = $('#modal-loader');
  if (!sp) return;

  const show = on && (force || shouldShowModalLoader());

  if (show){
    // Hide both tabs during the initial/empty load to avoid flashes
    $('#tabTournament').style.display = 'none';
    $('#tabRanking').style.display    = 'none';
    sp.style.display = 'flex';
  } else {
    sp.style.display = 'none';
    // Reveal whichever tab is active
    showTab(activeTab());
  }
  
}

/* -------------------- MODAL CONTENT CHECKS -------------------- */
function hasTournamentContent(){
  const w = $('#wBody'), l = $('#lBody');
  const wHas = !!(w && w.children.length);
  const lHas = !!(l && l.children.length);
  return wHas || lHas;
}

function hasRankingContent(){
  const tb = $('#rkBody');
  if (!tb) return false;
  const modalTid = $('#modal')?.dataset?.tid || '';
  const isCurrent = (tb.dataset.tid === modalTid);
  const hasAnyRow = tb.children.length > 0;
  const hasStatus = !!tb.querySelector('.k');
  return isCurrent && hasAnyRow && !hasStatus;
}

function shouldShowModalLoader(){
  // Show only when neither tab has painted real content yet
  return !(hasTournamentContent() || hasRankingContent());
}

/* -------------------- MODAL SNAPSHOT CACHE -------------------- */
/* -------------------- MODAL SNAPSHOT CACHE (deduped) -------------------- */
const ModalCache = new Map(); // tid -> { snapshot, hash }

/* super cheap hash for small strings */
function simpleHash(s){
  let h = 0;
  for (let i = 0; i < s.length; i++) {
    h = ((h << 5) - h + s.charCodeAt(i)) | 0;
  }
  return String(h);
}

/* build a minimal snapshot of what we need to restore quickly */
function buildSnapshot(){
  return {
    // meta text
    title: $('#mTitle')?.textContent || '',
    formatTxt: $('#mFormat')?.textContent || '',
    gameToTxt: $('#mGameTo')?.textContent || '',
    playersTxt: $('#mPlayers')?.textContent || '',
    // tabs + which was active
    activeTab: activeTab(),
    // sections HTML
    wHead: $('#wHead')?.innerHTML || '',
    wBody: $('#wBody')?.innerHTML || '',
    lHead: $('#lHead')?.innerHTML || '',
    lBody: $('#lBody')?.innerHTML || '',
    // keep ranking snapshot light; table can be large, but restoring is fine
    rkBody: $('#rkBody')?.innerHTML || '',
    losersVisible: ($('#losersSection')?.style.display !== 'none'),
  };
}

function snapshotToHash(s){
  // hash only the fields that, when changed, matter for rerender
  return simpleHash(
    s.title + '|' + s.formatTxt + '|' + s.gameToTxt + '|' + s.playersTxt + '|' +
    s.activeTab + '|' +
    s.wHead + '|' + s.wBody + '|' + s.lHead + '|' + s.lBody + '|' +
    s.rkBody + '|' + (s.losersVisible ? '1':'0')
  );
}

/* Update cache only if changed */
function updateModalCache(tid){
  const snap = buildSnapshot();
  const hash = snapshotToHash(snap);
  const key = String(tid);

  const prev = ModalCache.get(key);
  if (prev && prev.hash === hash) return; // no change → no work
  ModalCache.set(key, { snapshot: snap, hash });
}

/* Restore from cache */
function restoreModal(t){
  if (!t || !t.id) return false;
  const rec = ModalCache.get(String(t.id));
  if (!rec) return false;
  const s = rec.snapshot;

  // meta
  if ($('#mTitle'))  $('#mTitle').textContent = s.title;
  if ($('#mFormat')) $('#mFormat').textContent = s.formatTxt;
  if ($('#mGameTo')) $('#mGameTo').textContent = s.gameToTxt;
  if ($('#mPlayers'))$('#mPlayers').textContent = s.playersTxt;

  // content
  if ($('#wHead')) $('#wHead').innerHTML = s.wHead;
  if ($('#wBody')) $('#wBody').innerHTML = s.wBody;
  if ($('#lHead')) $('#lHead').innerHTML = s.lHead;
  if ($('#lBody')) $('#lBody').innerHTML = s.lBody;

  const rk = $('#rkBody');
  if (rk){
    rk.dataset.tid = String(t.id);   // <-- important
    rk.innerHTML = s.rkBody;
  }

  $('#losersSection').style.display = s.losersVisible ? '' : 'none';

  // show modal + correct tab
  showModal();
  $$('.tab').forEach(b=>b.classList.remove('active'));
  const tabBtn = $(`.tab[data-tab="${s.activeTab}"]`) || $$('.tab')[0];
  tabBtn?.classList.add('active');
  showTab(s.activeTab);

  // no spinner when restoring cached content
  setModalLoading(false);

  return true;
}

function resetModal() {
  // wipe visible content
  $('#mTitle').textContent = 'Tournament';
  $('#mFormat').textContent = '—';
  $('#mGameTo').textContent = '—';
  $('#mPlayers').textContent = '—';

  $('#wHead').innerHTML = '';
  $('#wBody').innerHTML = '';
  $('#lHead').innerHTML = '';
  $('#lBody').innerHTML = '';
  $('#rkBody').innerHTML = '';
  const rk = $('#rkBody');
  if (rk) rk.dataset.tid = '';

  // default visibility
  $('#tabTournament').style.display = 'none';
  $('#tabRanking').style.display = 'none';
  $('#losersSection').style.display = 'none';

  // clear metadata
  const modal = $('#modal');
  if (modal) {
    delete modal.dataset.tid;
    delete modal.dataset.format;
    delete modal.dataset.raceTo;
    delete modal.dataset.fetchToken;
    delete modal.dataset.rkToken; 
  }

  // show loader (optional)
  const sp = $('#modal-loader');
  if (sp) sp.style.display = 'flex';
}


/* ---------- CURRENT TOURNAMENT REFRESHER (5s, no globals) ---------- */
const CurrentTournamentRefresher = (() => {
  let iv = null;
  let current = null; // { id, format }

  async function refreshNow() {
    if (!current) return;
    if (!current?.id) return;

    try {

      const [players, matches] = await Promise.all([
        listPlayers(current.id),
        listMatches(current.id),
      ]);

      const playersById = Object.fromEntries(players.map(p => [String(p.id), p]));
      const grid = splitMatches(matches);

      // Winners
      const isDouble = String(current?.format || 'single').toLowerCase() === 'double';
      renderWinnersWithGF($('#wHead'), $('#wBody'), grid.winners, grid.finals, playersById, isDouble);
      $('#losersSection').style.display = isDouble ? '' : 'none';
      if (isDouble) {
        renderBracketArea($('#lHead'), $('#lBody'), grid.losers, playersById, 'L', 'space-around');
      } else {
        $('#lHead').innerHTML = '';
        $('#lBody').innerHTML = '';
      }

      if ($('#tabRanking').style.display !== 'none') {
        Ranking.refresh(current.id);
      }

      // keep cache fresh without duplicating work (hash prevents double writes)
      updateModalCache(current.id);
    } catch (e) {
      console.log('Tournament refresh failed:', e.message);
    }
  }

  return {
    start(tournament, intervalMs = 50000) {
      this.stop();
      current = {
        id: String(tournament.id),
        format: String(tournament.format || 'single'),
      };
      // first pull immediately, then every intervalMs
      refreshNow();
      iv = setInterval(refreshNow, intervalMs);
    },
    stop() {
      if (iv) clearInterval(iv);
      iv = null;
      current = null;
    },
    refreshNow, // optional: expose for manual punch-in
  };
})();


/* -------------------- MODAL (VIEW) -------------------- */
function showModal(){ $('#modal').classList.add('show'); }
function hideModal(){ 
  $('#modal').classList.remove('show'); 
  CurrentTournamentRefresher.stop();
  resetModal();
}
$('#closeBtn').addEventListener('click', hideModal);
$('#modal').addEventListener('click', (e)=>{ if (e.target===e.currentTarget) hideModal(); });

/* Tabs */
$$('.tab').forEach(btn=>{
  btn.addEventListener('click', async ()=>{
    $$('.tab').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    const tab = btn.dataset.tab;

    $('#tabTournament').style.display = (tab==='tournament') ? '' : 'none';
    $('#tabRanking').style.display   = (tab==='ranking')    ? '' : 'none';

    const tid = $('#modal')?.dataset?.tid || null;
    if (!tid) return;

    if (tab === 'ranking'){
      const modal = $('#modal');
      const tid = String(modal.dataset.tid || '');
      $('#rkBody').dataset.tid = tid;

      // new ranking token for this click
      const rkToken2 = String(Date.now());
      modal.dataset.rkToken = rkToken2;

      if (!hasRankingContent()){
        $('#rkBody').innerHTML = '';
        setModalLoading(true, { force: true });
        try {
          await Ranking.refresh(tid, { force: true, token: rkToken2 }); // pass token
        } finally {
          setModalLoading(false);
        }
      } else {
        Ranking.refresh(tid, { token: rkToken2 }); // silent refresh still guarded
      }
    }

  });
});


/* -------------------- MODAL META -------------------- */
function pluralize(n, one, many){ return `${n} ${n===1?one:many}`; }

/** Paints status/format/players/game-to in the modal header */
function paintModalMeta({ format, race_to }, players=[], matches=[]){
  // Status
  const st = $('#mStatus');
  if (st){
    st.innerHTML = `Live <span class="status-indicator">●</span>`;
  }

  // Format
  const fmtEl = $('#mFormat');
  if (fmtEl) fmtEl.innerHTML = fmtFormat(format||'—');

  // Players (prefer actual fetched count)
  const pc = Array.isArray(players) ? players.length : Number(players)||0;
  const pEl = $('#mPlayers');
  if (pEl) pEl.innerHTML = pluralize(pc, 'Participant', 'Participants');

  // Game to
  const gt = Number(race_to||0);
  const gEl = $('#mGameTo');
  if (gEl) gEl.innerHTML = `Game to: ${gt > 0 ? gt : '—'}`;
}


/* -------------------- BRACKET RENDER -------------------- */
function splitMatches(ms){
  const W={}, L={}, G=[];
  (ms||[]).forEach(m=>{
    const br = String(m.bracket||'W').toUpperCase();
    const key = String(m.round||1);
    if (br==='G') G.push(m);
    else if (br.startsWith('L')) (L[key] ||= []).push(m);
    else (W[key] ||= []).push(m);
  });
  const byRound = (obj)=>{
    return Object.keys(obj).sort((a,b)=>Number(a)-Number(b))
      .map(r=>({ title:r, matches:(obj[r]||[]).sort((a,b)=> String(a.id).localeCompare(String(b.id))) }));
  };
  return { winners: byRound(W), losers: byRound(L), finals: G.sort((a,b)=> String(a.id).localeCompare(String(b.id))) };
}

function makeMatchCard(m, playersById, isGF=false){
  const A = playersById[m.slot_a_player_id]||{};
  const B = playersById[m.slot_b_player_id]||{};
  const aSeed = A.seed ?? '-';
  const bSeed = B.seed ?? '-';
  
  let isMatchBye = m.bye;
  let isAbye = ((aSeed == '-') && bSeed != '-') && isMatchBye;
  let isBbye = ((bSeed == '-') && aSeed != '-') && isMatchBye;

  const aScore = (m.slot_a_score===''||m.slot_a_score==null)?0:Number(m.slot_a_score);
  const bScore = (m.slot_b_score===''||m.slot_b_score==null)?0:Number(m.slot_b_score);
  const wrap = document.createElement('div');
  wrap.className = 'mx' + (isGF?' gfinal':'');
  wrap.setAttribute('data-mid', m.id);

  wrap.innerHTML = `
    <div class="mx-slot">
      <div class="mx-left">
        <div class="mx-seed">${esc(aSeed)}</div>
        <div class="mx-name" title="${esc(A.name||'—')}">${formatName(esc(A.name||'—'))}</div>
      </div>
      <div class="mx-score ${(((meta.race_to == aScore) && aScore != bScore) || isBbye) ? "winner" : ""}"><span>${aScore}</span></div>
    </div>
    <div class="mx-slot">
      <div class="mx-left">
        <div class="mx-seed">${esc(bSeed)}</div>
        <div class="mx-name" title="${esc(B.name||'—')}">${formatName(esc(B.name||'—'))}</div>
      </div>
      <div class="mx-score ${(((meta.race_to == bScore) && aScore != bScore) || isAbye) ? "winner" : ""}"><span>${bScore}</span></div>
    </div>
  `;
  return wrap;
}

function renderBracketArea(headEl, bodyEl, rounds, playersById, prefix='W', justify='space-around'){
  headEl.innerHTML = '';
  bodyEl.innerHTML = '';
  if (!rounds.length){
    const none = document.createElement('div');
    none.className='k';
    none.textContent = 'No matches.';
    bodyEl.appendChild(none);
    return;
  }
  // headers
  rounds.forEach(col=>{
    const hc = document.createElement('div');
    hc.className='br-head-cell';
    hc.innerHTML = `<div class="round-head">${esc(prefix)} · R${esc(col.title)}</div>`;
    headEl.appendChild(hc);
  });

  // columns
  rounds.forEach(col=>{
    const c = document.createElement('div');
    c.className='col';
    const lane = document.createElement('div');
    lane.className='lane';
    lane.style.display = "flex";
    lane.style.flexDirection = "column";
    lane.style.height = "100%";
    lane.style.justifyContent = "space-around";

    const roundNum = Number(col.title);
    const hideByesHere = HIDE_BYE_RULES[prefix]?.has(roundNum) === true;

    col.matches.forEach(m=>{
      if (hideByesHere && isByeMatch(m, playersById)) {
        // keep spacing but hide the visible BYE card
        lane.appendChild(makeGhostCard());
      } else {
        lane.appendChild(makeMatchCard(m, playersById, false));
      }
    });

    c.appendChild(lane);
    bodyEl.appendChild(c);
  });
}

/* -------------------- BYE RULES + HELPERS -------------------- */
// Which rounds (per bracket) should hide BYEs but keep placeholders
const HIDE_BYE_RULES = {
  W: new Set([1]), // Winners Round 1 (hide BYEs)
  L: new Set([]),  // (optional) e.g. new Set([2]) to hide Losers R2 BYEs
};
function formatName(fullName) {
  if (!fullName) return "";

  const parts = fullName.trim().split(/\s+/); // split by spaces
  if (parts.length === 1) {
    return parts[0]; // single name only
  }

  const firstName = parts[0];
  const lastName = parts[parts.length - 1];
  const firstInitial = firstName.charAt(0).toUpperCase();

  return `${firstInitial}. ${lastName}`;
}
/** True if this match is a BYE (one-sided) or server-marked BYE */
function isByeMatch(m, playersById) {
  if (m?.bye) return true; // trust server if it flags BYE
  const hasA = !!m.slot_a_player_id && !!playersById[m.slot_a_player_id];
  const hasB = !!m.slot_b_player_id && !!playersById[m.slot_b_player_id];
  return hasA ^ hasB; // XOR → only one side present
}

/** Transparent placeholder that occupies the same space as a match card */
function makeGhostCard() {
  const g = document.createElement('div');
  g.className = 'mx';
  g.style.visibility = 'hidden';     // keep size, hide visually
  g.style.pointerEvents = 'none';    // not interactive
  return g;
}
/* ---------- LIVE REFRESH (no window globals) ---------- */
const LiveRefresh = (() => {
  let iv = null;

  const getOpenTournament = () => {
    const modal = $('#modal');
    if (!modal || !modal.classList.contains('show')) return null;
    const tid = modal.dataset.tid;
    if (!tid) return null;
    return {
      id: tid,
      format: modal.dataset.format || 'single',
      race_to: modal.dataset.raceTo || ''
    };
  };

  async function refreshOnce() {
    // always keep list fresh
    await load(currentPage, {quiet: true}).catch(() => {});

    // if modal has an active tournament, refresh its view too
    const t = getOpenTournament();
    if (!t) return;

    try {
      const [players, matches] = await Promise.all([
        listPlayers(t.id),
        listMatches(t.id)
      ]);

      const playersById = Object.fromEntries(players.map(p => [String(p.id), p]));
      const grid = splitMatches(matches);

      // Winners
      renderBracketArea($('#wHead'), $('#wBody'), grid.winners, playersById, 'W', 'space-around');

      // Losers (double only)
      const isDouble = String(t.format || 'single').toLowerCase() === 'double';
      $('#losersSection').style.display = isDouble ? '' : 'none';
      if (isDouble) {
        renderBracketArea($('#lHead'), $('#lBody'), grid.losers, playersById, 'L', 'space-around');
      } else {
        $('#lHead').innerHTML = '';
        $('#lBody').innerHTML = '';
      }


      // Standings
      renderRanking(t.id);
    } catch (e) {
      console.log('Live refresh (modal) failed:', e.message);
    }
  }

  return {
    enable(intervalMs = 50000) {
      this.disable();
      // immediate pull
      refreshOnce();
      iv = setInterval(refreshOnce, intervalMs);
    },
    disable() {
      if (iv) clearInterval(iv);
      iv = null;
    }
  };
})();

/** Render Winners with GF appended as the last column when double elimination */
function renderWinnersWithGF(headEl, bodyEl, winnersRounds, finals, playersById, isDouble){
  // First paint the regular Winners columns (with BYE ghosting already inside)
  renderBracketArea(headEl, bodyEl, winnersRounds, playersById, 'W', 'space-around');

  // Then, if double-elim and finals exist, append a "GF" column on the right
  if (isDouble && finals && finals.length){
    // Header cell
    const hc = document.createElement('div');
    hc.className = 'br-head-cell';
    hc.innerHTML = `<div class="round-head">GF</div>`;
    headEl.appendChild(hc);

    // Column with centered GF card(s)
    const c = document.createElement('div'); 
    c.className = 'col';
    const lane = document.createElement('div'); 
    lane.className = 'lane';
    lane.style.alignItems = 'center';
    lane.style.justifyContent = 'space-around';

    finals.forEach(m => lane.appendChild(makeMatchCard(m, playersById, true)));
    c.appendChild(lane);
    bodyEl.appendChild(c);
  }
}


/* -------------------- RANKING RENDER -------------------- */
function renderRanking(tournament_id){
  return Ranking.refresh(tournament_id, { force: true });
}
/* ---------- RANKING: DIFF & PATCH (only when visible) ---------- */
const Ranking = (() => {
  // cache per tournament
  const cache = new Map(); // tid -> { rowsByKey: Map, order: string[] }

  const tbody = () => $('#rkBody');
  const isVisible = () => $('#tabRanking') && $('#tabRanking').style.display !== 'none';

  // stable key for a row — prefer player id if present; fallback to name+seed
  const keyOf = (s) => String(s.player_id ?? `${s.name || ''}#${s.seed ?? ''}`);

  const getTime = (t) =>{
    if(!t)return "";
    time = new Date(t);

    hours = time.getHours();
    minutes = time.getMinutes();

    return `${hours}:${minutes}`;
  }
  // normalized shape used for diffing
  const norm = (s) => ({
    key: keyOf(s),
    rank: Number(s.rank),
    name: String(s.name ?? ''),
    seed: s.seed ?? '',
    wins: Number(s.wins ?? 0),
    losses: Number(s.losses ?? 0),
    win_pct: Number((s.win_pct ?? 0) * 100), // store as %
    frames_for: Number(s.frames_for ?? 0),
    frames_against: Number(s.frames_against ?? 0),
    frame_diff: (Number(s.frame_diff) >= 0 ? '+' : '') + `${Number(s.frame_diff)}` ,
    eliminated: !!s.eliminated,
    last_result: String(s.last_result ?? ''),
  });

  // render a single <tr> (used on insert)
  function renderRow(r) {
    const tr = document.createElement('tr');
    tr.dataset.key = r.key;
    let result = esc(r.last_result);
    let lastClass = (result == "W") ? "won" : (result == "L") ? "lost" : "";

    tr.innerHTML = `
      <td class="cell-rank">${r.rank}</td>
      <td class="cell-name"><span class="cell-name-span">${esc(r.name)}</span></td>
      <td class="cell-seed">${r.seed ?? ''}</td>
      <td class="cell-wins">${r.wins}</td>
      <td class="cell-losses">${r.losses}</td>
      <td class="cell-winpct">${r.win_pct.toFixed(1)}%</td>
      <td class="cell-fp">${r.frames_for}:${r.frames_against}</td>
      <td class="cell-diff">${r.frame_diff}</td>
      <td class="cell-elim">${r.eliminated ? 'Yes':'No'}</td>
      <td class="cell-last"><span class="${lastClass}">${result}</span></td>
    `;
    return tr;
  }

  // patch existing <tr> cells (only touched fields)
  function patchRow(tr, r) {
    const set = (sel, val) => {
      const el = tr.querySelector(sel);
      if (el && el.textContent !== String(val)) el.textContent = String(val);
    };
    set('.cell-rank', r.rank);
    set('.cell-name', r.name);
    set('.cell-seed', r.seed ?? '');
    set('.cell-wins', r.wins);
    set('.cell-losses', r.losses);
    set('.cell-winpct', `${r.win_pct.toFixed(1)}%`);
    set('.cell-fp', `${r.frames_for}:${r.frames_against}`);
    set('.cell-diff', r.frame_diff);
    set('.cell-elim', r.eliminated ? 'Yes' : 'No');

    // last cell might include " · date"
    const lastText = `${r.last_result}${r.last_result_at ? ' · '+r.last_result_at : ''}`;
    set('.cell-last', lastText);
  }

  // re-order DOM rows to match new order with minimal moves
  function reorderRows(tid, newOrder) {
    const tb = tbody();
    const currentRows = Array.from(tb.querySelectorAll('tr'));
    const indexByKey = new Map(newOrder.map((k,i)=>[k,i]));

    // stable minimal reinsert approach
    currentRows.sort((a,b)=>{
      return (indexByKey.get(a.dataset.key) ?? 1e9) - (indexByKey.get(b.dataset.key) ?? 1e9);
    }).forEach((tr, idx) => {
      if (tb.children[idx] !== tr) tb.insertBefore(tr, tb.children[idx] || null);
    });

    cache.get(tid).order = newOrder.slice();
  }

  function ensureCache(tid) {
    if (!cache.has(tid)) cache.set(tid, { rowsByKey: new Map(), order: [] });
    return cache.get(tid);
  }

  async function refresh(tid, { force = false, token = ''} = {}) {
    // only fetch/repaint if Ranking tab visible, unless forced
    if (!force && !isVisible()) return;

    const tb = tbody();
    if (!tb) return;

    tb.dataset.tid = String(tid);
    try {
      const j = await getRanking(tid);

      const modal = $('#modal');
      if (!modal) return;
      if (modal.dataset.tid !== String(tid)) return;      
      if (token && modal.dataset.rkToken !== token) return;  

      const rows = (j.standings || []).map(norm);

      // initial empty state
      if (!rows.length) {
        tb.innerHTML = '<tr><td colspan="11" class="k" style="padding:16px">No standings yet.</td></tr>';
        cache.set(tid, { rowsByKey: new Map(), order: [] });
        return;
      }

      const c = ensureCache(tid);
      const currentKeys = new Set(c.order);
      const newKeys = rows.map(r => r.key);
      const newKeySet = new Set(newKeys);

      // 1) insert/update
      if (!tb.querySelector('tr') || !currentKeys.size) {
        // first paint (fast path)
        tb.innerHTML = '';
        rows.forEach(r => {
          const tr = renderRow(r);
          tb.appendChild(tr);
          c.rowsByKey.set(r.key, r);
        });
        c.order = newKeys;
        return;
      }

      // patch pass
      rows.forEach((r, idx) => {
        const existingTr = tb.querySelector(`tr[data-key="${CSS.escape(r.key)}"]`);
        if (existingTr) {
          // compare with cache; only patch if changed
          const prev = c.rowsByKey.get(r.key);
          if (!prev ||
              prev.rank !== r.rank ||
              prev.name !== r.name ||
              String(prev.seed) !== String(r.seed) ||
              prev.wins !== r.wins ||
              prev.losses !== r.losses ||
              prev.win_pct !== r.win_pct ||
              prev.frames_for !== r.frames_for ||
              prev.frames_against !== r.frames_against ||
              prev.frame_diff !== r.frame_diff ||
              prev.eliminated !== r.eliminated ||
              prev.last_result !== r.last_result ||
              prev.last_result_at !== r.last_result_at) {
            patchRow(existingTr, r);
            c.rowsByKey.set(r.key, r);
          }
        } else {
          // new row
          const tr = renderRow(r);
          // place at correct index
          tb.insertBefore(tr, tb.children[idx] || null);
          c.rowsByKey.set(r.key, r);
        }
      });

      // 2) remove missing rows
      Array.from(tb.querySelectorAll('tr')).forEach(tr => {
        const k = tr.dataset.key;
        if (k && !newKeySet.has(k)) {
          tr.remove();
          c.rowsByKey.delete(k);
        }
      });

      // 3) order rows
      reorderRows(tid, newKeys);

    } catch (err) {
      // keep current DOM; show a small inline error only if tbody empty
      if (!tbody().children.length) {
        tbody().innerHTML = `<tr><td colspan="11" class="k" style="padding:16px;color:#fca5a5">Failed: ${esc(err.message || err)}</td></tr>`;
      }
      console.log('Ranking refresh failed:', err.message);
    }
  }

  return { refresh };
})();


/* -------------------- OPEN MODAL (LOAD DATA) -------------------- */
async function openModal(t){
  // meta header
  $('#mTitle').textContent = t.name || 'Tournament';

  // ensure Tournament tab visible by default
  $$('.tab').forEach(b=>b.classList.remove('active'));
  $$('.tab')[0].classList.add('active');
  $('#tabTournament').style.display = 'none';
  $('#tabRanking').style.display = 'none';

  // clear grids
  $('#wHead').innerHTML = $('#wBody').innerHTML = '';
  $('#lHead').innerHTML = $('#lBody').innerHTML = '';
  $('#rkBody').innerHTML = '';
  $('#rkBody').dataset.tid = String(t.id || '');

  showModal();
  
  const modal = $('#modal');
  modal.dataset.tid = String(t.id);
  modal.dataset.format = String(t.format || 'single');
  modal.dataset.raceTo = String(t.race_to || '');
  meta.race_to = Number(modal.dataset.raceTo);

  // mark this request so late responses can be ignored
  const token = String(Date.now());
  modal.dataset.fetchToken = token;

  // --- Add these lines (ranking token) ---
  $('#rkBody').dataset.tid = String(t.id || '');
  const rkToken = String(Date.now());
  modal.dataset.rkToken = rkToken;
  // ---------------------------------------

  // Only show modal loader if neither tab has content yet
  setModalLoading(true);

  try{
    const [players, matches] = await Promise.all([listPlayers(t.id), listMatches(t.id)]);
    if (modal.dataset.fetchToken !== token) return;

    paintModalMeta({ format: t.format, race_to: t.race_to }, players, matches);

    const playersById = Object.fromEntries(players.map(p=>[String(p.id), p]));
    const grid = splitMatches(matches);

    // Winners
    const isDouble = String(t.format||'single').toLowerCase()==='double';

    // Winners with inline GF for double-elim
    renderWinnersWithGF($('#wHead'), $('#wBody'), grid.winners, grid.finals, playersById, isDouble);

    // Losers (double only)
    $('#losersSection').style.display = isDouble ? '' : 'none';
    if (isDouble){
      renderBracketArea($('#lHead'), $('#lBody'), grid.losers, playersById, 'L', 'space-around');
    }

    // update cache once based on current DOM
    updateModalCache(t.id);

    // Rankings tab content (lazy-load on open)
    await Ranking.refresh(String(t.id), { force: true, token: rkToken }); // <-- pass token


    setModalLoading(false);

    // start refresher only if still the same open
    if (modal.dataset.fetchToken === token) {
      CurrentTournamentRefresher.start(t, 10000);
    }
  }catch(e){
    console.log('Failed to load tournament view: ' + e.message);
    setModalLoading(false);
  }
}

/* -------------------- BOOT -------------------- */
load(1)
</script>

</body>
</html>