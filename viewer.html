<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Active Tournaments (Read-Only)</title>
<style>
  :root{
    --bg:#0b1016;
    --ink:#e6edf7;
    --muted:#9aa3b2;
    --panel:#0f141a;
    --ring:#263043;
    --focus:#3b82f6;
    --good:#19c37d;
    --warn:#f59e0b;
    --bad:#ef4444;
    --chip:#151a20;

        /* brand + surfaces */
    --bg:#121419;
    --panel:#20242c;
    --ring:#2b3140;
    --focus:#3b82f6;

    /* text */
    --ink:#e9edf4;
    --muted:#9aa3b2;

    /* states */
    --ok:#22c55e;
    --err:#ef4444;

    /* bracket specifics */
    --slot-bg:#3a3f48;     /* row background */
    --seed-bg:#4a4f58;     /* brighter than slot */
    --score-bg:#2d3139;    /* score box */
    --score-win:#ff6a2f;   /* winner highlight */
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,"Noto Sans",sans-serif}
  .wrap{max-width:1200px; min-width: 900px;margin:22px auto;padding:0 12px}
  .card{background:var(--panel);border:1px solid var(--ring);border-radius:14px;padding:16px}
  .head{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
  .tools{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{appearance:none;border:1px solid var(--ring);background:#101621;color:var(--ink);padding:8px 12px;border-radius:8px;cursor:pointer}
  .btn[disabled]{opacity:.55;cursor:not-allowed}
  .btn.ghost{background:#161b23}
  .list .row{display:flex;justify-content:space-between;align-items:center;background:#191d24;border:1px solid var(--ring);border-radius:10px;padding:10px 14px;margin-bottom:8px}
  .row .left{display:flex;align-items:center;gap:24px; margin-right: 100px;}
  .bits{display:flex;gap:16px;flex-wrap:wrap;color:#ccc}
  .muted{color:var(--muted)}
  .pager{display:flex;gap:8px;align-items:center;margin-top:10px;flex-wrap:wrap}
  .k{font-size:12px;color:var(--muted)}
  .chip{background:var(--chip);border:1px solid var(--ring);border-radius:999px;padding:2px 8px;font-size:12px}
  /* Modal */
  .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;z-index:30}
  .modal{width:min(1100px,95vw);max-height:90vh;background:#0f141a;border:1px solid var(--ring);border-radius:12px;overflow:hidden;display:flex;flex-direction:column}
  .modal-backdrop.show{display:flex}


  .modal-h{
    display:flex;
    flex-direction: column;
    padding:12px;
    border-bottom:1px solid var(--ring);
    gap:8px
  }

  .title-row .title{font-weight:700; font-size: 16px;}
  .title-row{
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 10px;
  }
  .details-row{
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .details-row .format{
    font-size: 12px;
    color: #eee;
  }
  .details-row .players{
    font-size: 12px;
    color: #eee;
  }
  .details-row .game-to{
    font-size: 12px;
    color: #eee;
  }
  .status-box{
    display:flex;
    flex-direction: row;
    gap: 8px;
  }
  .status .status-indicator{
    color: rgb(220, 92, 92);
    padding-left: 5px;
  }
  .status-box div{
    gap:8px; max-width: max-content;
    appearance:none;border:1px solid var(--ring);
    background:#0f141a;color:var(--ink);
    padding:8px 10px;border-radius:8px;
  }
  .tabs{display:flex;gap:8px; max-width: max-content;}
  .tab{appearance:none;border:1px solid var(--ring);background:#0f141a;color:var(--ink);padding:8px 10px;border-radius:8px;cursor:pointer}
  .tab.active{outline:2px solid var(--focus);outline-offset:1px;background:#132032}
  .modal-b{padding:12px;overflow:auto}
  /* Players list */
  .p-wrap{ border:1px solid var(--ring); border-radius:8px; background:#11161d; padding:12px }
  .p-row{
    display:flex; align-items:center; justify-content:space-between;
    background:#191d24; border:1px solid var(--ring); border-radius:8px;
    padding:10px 12px; margin-bottom:8px;
  }
  .p-row.alt{ background: var(--panel); } /* a bit brighter than normal */
  .p-seed{ font-size:12px; color:#cfd6e3; background:#4a4f58; border:1px solid var(--ring);
    min-width:28px; text-align:center; border-radius:6px; padding:2px 6px; margin-right:10px }
  .p-name{ flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
  /* Bracket shell */
  .section{margin-bottom:18px}
  .section-head{display:flex;align-items:center;justify-content:center;font-size:12px;color:#cfd6e3;text-transform:uppercase;letter-spacing:.04em;margin:0 0 10px 0}
  .grid-shell{border:1px solid var(--ring);border-radius:8px;background:#11161d;padding:14px;width:100%;overflow:auto;box-sizing:border-box}
  .round-head{font-size:12px;color:#9aa3b2;text-transform:uppercase;letter-spacing:.04em;margin:0 0 8px 0;text-align:center}
  .br-header{display:flex;gap:18px;align-items:baseline;background:#11161d;position:sticky;top:0;padding-top:2px;padding-bottom:6px}
  .br-head-cell{min-width:240px;flex:0 0 auto;text-align:center}
  .br-body{display:flex;gap:18px;align-items:stretch;padding-bottom:4px}
  .col{display:flex;flex-direction:column;flex:0 0 auto;width:240px; min-height: 100%;}
  .lane{display:flex;flex-direction:column;justify-content:space-around;gap:16px; height: 100%;}
  /* Match card */
  .mx{width:220px;border:1px solid var(--ring);border-radius:4px;overflow:hidden;background:#22262d;display:grid;grid-template-rows:28px 28px auto;}
  .mx-slot{display:flex;align-items:stretch;justify-content:space-between;background:#3a3f48;font-size:13px,}
  .mx-slot:first-child{
    margin-bottom: 1px;
  }
  .mx-left{display:flex;align-items:center;flex:1;min-width:0}
  .mx-seed{background:#4a4f58;color:#cfd6e3;font-size:11px;font-weight:600;min-width:24px;padding:0 4px;text-align:center;display:flex;align-items:center;justify-content:center;height:100%;border-right:1px solid var(--ring)}
  .mx-name{flex:1;padding:0 8px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis; max-width: 138px; text-align: left;}
  .mx-score{display: flex; justify-content: center; align-items: center; height:100%; width:32px; margin:0; padding:0; border:none; border-left:1px solid var(--ring);
    text-align:center; font-weight:800; font-size:12px; background:var(--score-bg); color:#bfc6d1; align-self: "center";}
  .mx-score.winner{ background:var(--score-win); color:#fff }
  .mx-actions{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:6px;background:#1b2027;border-top:1px solid var(--ring);font-size:11px}
  .badge{font-size:10px;padding:3px 6px;border-radius:6px;color:#cfd6e3;border:1px solid transparent}
  .badge.pending{background:#2a2f37;border-color:#3a404c}
  .badge.in_progress{background:#112036;border-color:#2a406b}
  .badge.completed{background:#0f2a17;border-color:#214b32}
  /* Finals card style */
  .mx.gfinal{background:linear-gradient(180deg,#3a2a10 0%,#1f1608 100%);border-color:#facc15;box-shadow:0 0 14px rgba(250,204,21,.6)}
  .mx.gfinal .mx-slot{color:#fff7e0}
  /* Rankings */
  table{border-collapse:collapse;width:100%}
  th,td{border-bottom:1px solid #202632;padding:8px 10px;text-align:left}
  .cell-name{
    display: block;
    max-width: 310px;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis
  }
  th{font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:.04em}
  .right{float:right}
  /* Chips inline */
  .inline-chips{display:flex;gap:8px;flex-wrap:wrap}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="head">
        <h2 style="margin:0">Active Tournaments</h2>
        <div class="tools">
          <button class="btn" id="refreshBtn">Load</button>
        </div>
      </div>

      <div id="list" class="list"></div>

      <div class="pager">
        <button class="btn" id="prevBtn" disabled>Prev</button>
        <span class="k" id="pageInfo">Page 1 / 1 · Total: 0</span>
        <button class="btn" id="nextBtn" disabled>Next</button>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div id="modal" class="modal-backdrop">
    <div class="modal">
      <div class="modal-h">
        <div class="title-row">
            <div class="title" id="mTitle">Tournament</div>
        </div>
        <div class="details-row">
          <div class="status-box">
              <div class="status" id="mStatus">Live <span class="status-indicator">●</span></div>
              <div class="format" id="mFormat">...</div>
              <div class="game-to" id="mGameTo">...</div>
              <div class="players" id="mPlayers">...</div>
          </div>
          <div class="tabs">
            <button class="tab active" data-tab="tournament">Tournament</button>
            <button class="tab" data-tab="ranking">Ranking</button>
            <button class="btn ghost" id="closeBtn">Close</button>
          </div>
      </div>
        
      </div>
      <div class="modal-b">
        <div id="tabTournament">
          <div class="section">
            <div class="section-head">Winners Bracket</div>
            <div class="grid-shell">
              <div class="br-header" id="wHead"></div>
              <div class="br-body" id="wBody"></div>
            </div>
          </div>

          <div class="section" id="losersSection" style="display:none">
            <div class="section-head">Losers Bracket</div>
            <div class="grid-shell">
              <div class="br-header" id="lHead"></div>
              <div class="br-body" id="lBody"></div>
            </div>
          </div>
          
        </div>

        <div id="tabRanking" style="display:none">
          <div class="section">
            <div class="section-head">Standings</div>
            <div id="rkWrap" class="grid-shell" style="padding:0">
              <table id="rkTable">
                <thead>
                  <tr>
                    <th>#</th><th>Player</th><th>Seed</th><th>W</th><th>L</th><th>Win %</th>
                    <th>Frames</th><th>Diff</th><th>Elim</th><th>Latest</th>
                  </tr>
                </thead>
                <tbody id="rkBody"></tbody>
              </table>
            </div>
          </div>
        </div>
      </div><!-- /modal-b -->
    </div>
  </div>

<script>
/* -------------------- CONFIG -------------------- */
const API_BASE = 'https://script.google.com/macros/s/AKfycbwTcXAASeBn7eJjr7dPobxh7Lj5VtXMrClDGFZdgjgzptp8ZoC8_DT4ybmrgcGNkTaBJg/exec'; // <-- replace with your GAS Web App URL
const PAGE_SIZE = 5;

/* -------------------- UTIL -------------------- */
const $ = (q,root=document)=>root.querySelector(q);
const $$ = (q,root=document)=>Array.from(root.querySelectorAll(q));
const esc = (s)=>String(s==null?'':s)
  .replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
const fmtFormat = (raw)=> {
  const s = String(raw||'').toLowerCase();
  if (s==='double') return 'Double Elimination';
  if (s==='single') return 'Single Elimination';
  return raw || '—';
};
const fmtDate = (dt)=> {
  if (!dt) return '-';
  try{
    return new Date(dt).toLocaleString(undefined,{year:'numeric',month:'short',day:'numeric',hour:'2-digit',minute:'2-digit'});
  }catch{ return String(dt); }
};
const toForm = (obj)=> new URLSearchParams(obj);

/* -------------------- API -------------------- */
async function apiPost(formObj){
  const res = await fetch(API_BASE, {
    method:'POST',
    headers:{ 'Content-Type':'application/x-www-form-urlencoded;charset=UTF-8' },
    body: toForm(formObj)
  });
  if (!res.ok) throw new Error('Network error '+res.status);
  const json = await res.json();
  if (json && json.ok === false) throw new Error(json.error||'Server error');
  return json;
}
async function listTournaments({status='active', page=1, limit=PAGE_SIZE}={}){
  return apiPost({ action:'listTournaments', status, page, limit });
}
async function listPlayers(tournament_id){
  const j = await apiPost({ action:'listPlayers', tournament_id });
  return j.players || [];
}
async function listMatches(tournament_id){
  const j = await apiPost({ action:'listMatches', tournament_id });
  return j.matches || [];
}
async function getRanking(tournament_id){
  return apiPost({ action:'getRanking', tournament_id });
}

/* -------------------- STATE -------------------- */
let currentPage = 1;
let meta = { page:1, pages:1, total:0, has_prev:false, has_next:false, race_to:0 };
let timer = null;

/* -------------------- LIST RENDER -------------------- */
function renderList(items){
  const root = $('#list');
  root.innerHTML = '';
  if (!items.length){
    const div = document.createElement('div');
    div.className='k';
    div.style.padding='6px 0';
    div.textContent = 'No active tournaments.';
    root.appendChild(div);
    return;
  }

  items.forEach(t=>{
    const row = document.createElement('div');
    row.className = 'row';

    const left = document.createElement('div');
    left.className = 'left';
    const name = document.createElement('span');
    name.style.fontWeight='700';
    name.style.fontSize='16px';
    name.textContent = t.name || '-';

    const bits = document.createElement('div');
    bits.className='bits';
    bits.innerHTML = `
      <span>${esc(fmtFormat(t.format))}</span>
      <span>Participants: ${Number(t.player_count)||0}</span>
      <span>Date: ${esc(fmtDate(t.start_time))}</span>
    `;

    left.appendChild(name);
    left.appendChild(bits);

    const right = document.createElement('div');
    right.style.display='flex';
    right.style.gap='8px';

    const btnView = document.createElement('button');
    btnView.className='btn';
    btnView.textContent='View';
    btnView.addEventListener('click', (e)=> {
        e.preventDefault();
        e.stopPropagation();
        openModal(t)
    });

    right.appendChild(btnView);

    row.appendChild(left);
    row.appendChild(right);
    root.appendChild(row);
  });
}

/* -------------------- PAGING -------------------- */
function syncPager(){
  $('#prevBtn').disabled = !meta.has_prev;
  $('#nextBtn').disabled = !meta.has_next;
  $('#pageInfo').textContent = `Page ${meta.page||currentPage} / ${meta.pages||1} · Total: ${meta.total??0}`;
}

/* -------------------- LOAD -------------------- */
async function load(page=1){
  $('#refreshBtn').disabled = true;
  $('#refreshBtn').textContent = 'Refreshing…';
  try{
    const data = await listTournaments({ status:'active', page, limit: PAGE_SIZE });
    renderList(data.tournaments||[]);
    meta = data.meta || meta;
    currentPage = meta.page || page;
    syncPager();
    $('#refreshBtn').textContent = data.tournaments?.length ? 'Refresh' : 'Load';
  }catch(e){
    console.log('Failed to load active tournaments: ' + e.message);
    renderList([]);
    meta = { page:1,pages:1,total:0,has_prev:false,has_next:false };
    syncPager();
    $('#refreshBtn').textContent = 'Load';
  }finally{
    $('#refreshBtn').disabled = false;
  }
}

$('#refreshBtn').addEventListener('click', ()=>load(currentPage));
$('#prevBtn').addEventListener('click', ()=> load(currentPage-1));
$('#nextBtn').addEventListener('click', ()=> load(currentPage+1));


/* ---------- CURRENT TOURNAMENT REFRESHER (5s, no globals) ---------- */
const CurrentTournamentRefresher = (() => {
  let iv = null;
  let current = null; // { id, format }

  async function refreshNow() {
    if (!current) return;

    try {
      const [players, matches] = await Promise.all([
        listPlayers(current.id),
        listMatches(current.id),
      ]);

      const playersById = Object.fromEntries(players.map(p => [String(p.id), p]));
      const grid = splitMatches(matches);

      // Winners
      const isDouble = String(current.format || 'single').toLowerCase() === 'double';
      renderWinnersWithGF($('#wHead'), $('#wBody'), grid.winners, grid.finals, playersById, isDouble);

      $('#losersSection').style.display = isDouble ? '' : 'none';
      if (isDouble) {
        renderBracketArea($('#lHead'), $('#lBody'), grid.losers, playersById, 'L', 'space-around');
      } else {
        $('#lHead').innerHTML = '';
        $('#lBody').innerHTML = '';
      }

      if ($('#tabRanking').style.display !== 'none') {
        Ranking.refresh(current.id);
      }

    } catch (e) {
      console.log('Tournament refresh failed:', e.message);
    }
  }

  return {
    start(tournament, intervalMs = 50000) {
      this.stop();
      current = {
        id: String(tournament.id),
        format: String(tournament.format || 'single'),
      };
      // first pull immediately, then every intervalMs
      refreshNow();
      iv = setInterval(refreshNow, intervalMs);
    },
    stop() {
      if (iv) clearInterval(iv);
      iv = null;
      current = null;
    },
    refreshNow, // optional: expose for manual punch-in
  };
})();


/* -------------------- MODAL (VIEW) -------------------- */
function showModal(){ $('#modal').classList.add('show'); }
function hideModal(){ 
  $('#modal').classList.remove('show'); 
  CurrentTournamentRefresher.stop();
}
$('#closeBtn').addEventListener('click', hideModal);
$('#modal').addEventListener('click', (e)=>{ if (e.target===e.currentTarget) hideModal(); });

/* Tabs */
$$('.tab').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    $$('.tab').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    const tab = btn.dataset.tab;

    $('#tabTournament').style.display = (tab==='tournament') ? '' : 'none';
    $('#tabRanking').style.display   = (tab==='ranking')    ? '' : 'none';

    const tid = $('#modal')?.dataset?.tid || null;

    if (tab === 'ranking' && tid) {
      Ranking.refresh(String(tid));
    }
  });
});


/* -------------------- MODAL META -------------------- */
function pluralize(n, one, many){ return `${n} ${n===1?one:many}`; }

/** Paints status/format/players/game-to in the modal header */
function paintModalMeta({ format, race_to }, players=[], matches=[]){
  // Status
  const st = $('#mStatus');
  if (st){
    st.innerHTML = `Live <span class="status-indicator">●</span>`;
  }

  // Format
  const fmtEl = $('#mFormat');
  if (fmtEl) fmtEl.innerHTML = fmtFormat(format||'—');

  // Players (prefer actual fetched count)
  const pc = Array.isArray(players) ? players.length : Number(players)||0;
  const pEl = $('#mPlayers');
  if (pEl) pEl.innerHTML = pluralize(pc, 'Participant', 'Participants');

  // Game to
  const gt = Number(race_to||0);
  const gEl = $('#mGameTo');
  if (gEl) gEl.innerHTML = `Game to: ${gt > 0 ? gt : '—'}`;
}


/* -------------------- BRACKET RENDER -------------------- */
function splitMatches(ms){
  const W={}, L={}, G=[];
  (ms||[]).forEach(m=>{
    const br = String(m.bracket||'W').toUpperCase();
    const key = String(m.round||1);
    if (br==='G') G.push(m);
    else if (br.startsWith('L')) (L[key] ||= []).push(m);
    else (W[key] ||= []).push(m);
  });
  const byRound = (obj)=>{
    return Object.keys(obj).sort((a,b)=>Number(a)-Number(b))
      .map(r=>({ title:r, matches:(obj[r]||[]).sort((a,b)=> String(a.id).localeCompare(String(b.id))) }));
  };
  return { winners: byRound(W), losers: byRound(L), finals: G.sort((a,b)=> String(a.id).localeCompare(String(b.id))) };
}

function makeMatchCard(m, playersById, isGF=false){
  const A = playersById[m.slot_a_player_id]||{};
  const B = playersById[m.slot_b_player_id]||{};
  const aSeed = A.seed ?? '-';
  const bSeed = B.seed ?? '-';

  let isAbye = ((aSeed == '-') && bSeed != '-');
  let isBbye = ((bSeed == '-') && aSeed != '-');

  const aScore = (m.slot_a_score===''||m.slot_a_score==null)?0:Number(m.slot_a_score);
  const bScore = (m.slot_b_score===''||m.slot_b_score==null)?0:Number(m.slot_b_score);
  const wrap = document.createElement('div');
  wrap.className = 'mx' + (isGF?' gfinal':'');
  wrap.setAttribute('data-mid', m.id);

  wrap.innerHTML = `
    <div class="mx-slot">
      <div class="mx-left">
        <div class="mx-seed">${esc(aSeed)}</div>
        <div class="mx-name" title="${esc(A.name||'—')}">${formatName(esc(A.name||'—'))}</div>
      </div>
      <div class="mx-score ${((meta.race_to == aScore) || isBbye) ? "winner" : ""}"><span>${aScore}</span></div>
    </div>
    <div class="mx-slot">
      <div class="mx-left">
        <div class="mx-seed">${esc(bSeed)}</div>
        <div class="mx-name" title="${esc(B.name||'—')}">${formatName(esc(B.name||'—'))}</div>
      </div>
      <div class="mx-score ${((meta.race_to == bScore) || isAbye) ? "winner" : ""}"><span>${bScore}</span></div>
    </div>
  `;
  return wrap;
}

function renderBracketArea(headEl, bodyEl, rounds, playersById, prefix='W', justify='space-around'){
  headEl.innerHTML = '';
  bodyEl.innerHTML = '';
  if (!rounds.length){
    const none = document.createElement('div');
    none.className='k';
    none.textContent = 'No matches.';
    bodyEl.appendChild(none);
    return;
  }
  // headers
  rounds.forEach(col=>{
    const hc = document.createElement('div');
    hc.className='br-head-cell';
    hc.innerHTML = `<div class="round-head">${esc(prefix)} · R${esc(col.title)}</div>`;
    headEl.appendChild(hc);
  });

  // columns
  rounds.forEach(col=>{
    const c = document.createElement('div');
    c.className='col';
    const lane = document.createElement('div');
    lane.className='lane';
    lane.style.display = "flex";
    lane.style.flexDirection = "column";
    lane.style.height = "100%";
    lane.style.justifyContent = "space-around";

    const roundNum = Number(col.title);
    const hideByesHere = HIDE_BYE_RULES[prefix]?.has(roundNum) === true;

    col.matches.forEach(m=>{
      if (hideByesHere && isByeMatch(m, playersById)) {
        // keep spacing but hide the visible BYE card
        lane.appendChild(makeGhostCard());
      } else {
        lane.appendChild(makeMatchCard(m, playersById, false));
      }
    });

    c.appendChild(lane);
    bodyEl.appendChild(c);
  });
}

/* -------------------- BYE RULES + HELPERS -------------------- */
// Which rounds (per bracket) should hide BYEs but keep placeholders
const HIDE_BYE_RULES = {
  W: new Set([1]), // Winners Round 1 (hide BYEs)
  L: new Set([]),  // (optional) e.g. new Set([2]) to hide Losers R2 BYEs
};
function formatName(fullName) {
  if (!fullName) return "";

  const parts = fullName.trim().split(/\s+/); // split by spaces
  if (parts.length === 1) {
    return parts[0]; // single name only
  }

  const firstName = parts[0];
  const lastName = parts[parts.length - 1];
  const firstInitial = firstName.charAt(0).toUpperCase();

  return `${firstInitial}. ${lastName}`;
}
/** True if this match is a BYE (one-sided) or server-marked BYE */
function isByeMatch(m, playersById) {
  if (m?.bye) return true; // trust server if it flags BYE
  const hasA = !!m.slot_a_player_id && !!playersById[m.slot_a_player_id];
  const hasB = !!m.slot_b_player_id && !!playersById[m.slot_b_player_id];
  return hasA ^ hasB; // XOR → only one side present
}

/** Transparent placeholder that occupies the same space as a match card */
function makeGhostCard() {
  const g = document.createElement('div');
  g.className = 'mx';
  g.style.visibility = 'hidden';     // keep size, hide visually
  g.style.pointerEvents = 'none';    // not interactive
  return g;
}
/* ---------- LIVE REFRESH (no window globals) ---------- */
const LiveRefresh = (() => {
  let iv = null;

  const getOpenTournament = () => {
    const modal = $('#modal');
    if (!modal || !modal.classList.contains('show')) return null;
    const tid = modal.dataset.tid;
    if (!tid) return null;
    return {
      id: tid,
      format: modal.dataset.format || 'single',
      race_to: modal.dataset.raceTo || ''
    };
  };

  async function refreshOnce() {
    // always keep list fresh
    await load(currentPage).catch(() => {});

    // if modal has an active tournament, refresh its view too
    const t = getOpenTournament();
    if (!t) return;

    try {
      const [players, matches] = await Promise.all([
        listPlayers(t.id),
        listMatches(t.id)
      ]);

      const playersById = Object.fromEntries(players.map(p => [String(p.id), p]));
      const grid = splitMatches(matches);

      // Winners
      renderBracketArea($('#wHead'), $('#wBody'), grid.winners, playersById, 'W', 'space-around');

      // Losers (double only)
      const isDouble = String(t.format || 'single').toLowerCase() === 'double';
      $('#losersSection').style.display = isDouble ? '' : 'none';
      if (isDouble) {
        renderBracketArea($('#lHead'), $('#lBody'), grid.losers, playersById, 'L', 'space-around');
      } else {
        $('#lHead').innerHTML = '';
        $('#lBody').innerHTML = '';
      }


      // Standings
      renderRanking(t.id);
    } catch (e) {
      console.log('Live refresh (modal) failed:', e.message);
    }
  }

  return {
    enable(intervalMs = 50000) {
      this.disable();
      // immediate pull
      refreshOnce();
      iv = setInterval(refreshOnce, intervalMs);
    },
    disable() {
      if (iv) clearInterval(iv);
      iv = null;
    }
  };
})();

/** Render Winners with GF appended as the last column when double elimination */
function renderWinnersWithGF(headEl, bodyEl, winnersRounds, finals, playersById, isDouble){
  // First paint the regular Winners columns (with BYE ghosting already inside)
  renderBracketArea(headEl, bodyEl, winnersRounds, playersById, 'W', 'space-around');

  // Then, if double-elim and finals exist, append a "GF" column on the right
  if (isDouble && finals && finals.length){
    // Header cell
    const hc = document.createElement('div');
    hc.className = 'br-head-cell';
    hc.innerHTML = `<div class="round-head">GF</div>`;
    headEl.appendChild(hc);

    // Column with centered GF card(s)
    const c = document.createElement('div'); 
    c.className = 'col';
    const lane = document.createElement('div'); 
    lane.className = 'lane';
    lane.style.alignItems = 'center';
    lane.style.justifyContent = 'space-around';

    finals.forEach(m => lane.appendChild(makeMatchCard(m, playersById, true)));
    c.appendChild(lane);
    bodyEl.appendChild(c);
  }
}


/* -------------------- RANKING RENDER -------------------- */
function renderRanking(tournament_id){
  return Ranking.refresh(tournament_id, { force: true });
}
/* ---------- RANKING: DIFF & PATCH (only when visible) ---------- */
const Ranking = (() => {
  // cache per tournament
  const cache = new Map(); // tid -> { rowsByKey: Map, order: string[] }

  const tbody = () => $('#rkBody');
  const isVisible = () => $('#tabRanking') && $('#tabRanking').style.display !== 'none';

  // stable key for a row — prefer player id if present; fallback to name+seed
  const keyOf = (s) => String(s.player_id ?? `${s.name || ''}#${s.seed ?? ''}`);

  const getTime = (t) =>{
    if(!t)return "";
    time = new Date(t);

    hours = time.getHours();
    minutes = time.getMinutes();

    return `${hours}:${minutes}`;
  }
  // normalized shape used for diffing
  const norm = (s) => ({
    key: keyOf(s),
    rank: Number(s.rank),
    name: String(s.name ?? ''),
    seed: s.seed ?? '',
    wins: Number(s.wins ?? 0),
    losses: Number(s.losses ?? 0),
    win_pct: Number((s.win_pct ?? 0) * 100), // store as %
    frames_for: Number(s.frames_for ?? 0),
    frames_against: Number(s.frames_against ?? 0),
    frame_diff: (Number(s.frame_diff) >= 0 ? '+' : '') + `${Number(s.frame_diff)}` ,
    eliminated: !!s.eliminated,
    last_result: String(s.last_result ?? ''),
  });

  // render a single <tr> (used on insert)
  function renderRow(r) {
    const tr = document.createElement('tr');
    tr.dataset.key = r.key;
    tr.innerHTML = `
      <td class="cell-rank">${r.rank}</td>
      <td class="cell-name">${esc(r.name)}</td>
      <td class="cell-seed">${r.seed ?? ''}</td>
      <td class="cell-wins">${r.wins}</td>
      <td class="cell-losses">${r.losses}</td>
      <td class="cell-winpct">${r.win_pct.toFixed(1)}%</td>
      <td class="cell-fp">${r.frames_for}:${r.frames_against}</td>
      <td class="cell-diff">${r.frame_diff}</td>
      <td class="cell-elim">${r.eliminated ? 'Yes':'No'}</td>
      <td class="cell-last">${esc(r.last_result)}</td>
    `;
    return tr;
  }

  // patch existing <tr> cells (only touched fields)
  function patchRow(tr, r) {
    const set = (sel, val) => {
      const el = tr.querySelector(sel);
      if (el && el.textContent !== String(val)) el.textContent = String(val);
    };
    set('.cell-rank', r.rank);
    set('.cell-name', r.name);
    set('.cell-seed', r.seed ?? '');
    set('.cell-wins', r.wins);
    set('.cell-losses', r.losses);
    set('.cell-winpct', `${r.win_pct.toFixed(1)}%`);
    set('.cell-fp', r.frames_for);
    set('.cell-fa', r.frames_against);
    set('.cell-diff', r.frame_diff);
    set('.cell-elim', r.eliminated ? 'Yes' : 'No');

    // last cell might include " · date"
    const lastText = `${r.last_result}${r.last_result_at ? ' · '+r.last_result_at : ''}`;
    set('.cell-last', lastText);
  }

  // re-order DOM rows to match new order with minimal moves
  function reorderRows(tid, newOrder) {
    const tb = tbody();
    const currentRows = Array.from(tb.querySelectorAll('tr'));
    const indexByKey = new Map(newOrder.map((k,i)=>[k,i]));

    // stable minimal reinsert approach
    currentRows.sort((a,b)=>{
      return (indexByKey.get(a.dataset.key) ?? 1e9) - (indexByKey.get(b.dataset.key) ?? 1e9);
    }).forEach((tr, idx) => {
      if (tb.children[idx] !== tr) tb.insertBefore(tr, tb.children[idx] || null);
    });

    cache.get(tid).order = newOrder.slice();
  }

  function ensureCache(tid) {
    if (!cache.has(tid)) cache.set(tid, { rowsByKey: new Map(), order: [] });
    return cache.get(tid);
  }

  async function refresh(tid, { force = false } = {}) {
    // only fetch/repaint if Ranking tab visible, unless forced
    if (!force && !isVisible()) return;

    const tb = tbody();
    if (!tb) return;

    // show spinner only if empty (avoid flicker during live updates)
    if (!tb.children.length) {
      tb.innerHTML = '<tr><td colspan="11" class="k" style="padding:16px">Loading…</td></tr>';
    }

    try {
      const j = await getRanking(tid);
      const rows = (j.standings || []).map(norm);

      // initial empty state
      if (!rows.length) {
        tb.innerHTML = '<tr><td colspan="11" class="k" style="padding:16px">No standings yet.</td></tr>';
        cache.set(tid, { rowsByKey: new Map(), order: [] });
        return;
      }

      const c = ensureCache(tid);
      const currentKeys = new Set(c.order);
      const newKeys = rows.map(r => r.key);
      const newKeySet = new Set(newKeys);

      // 1) insert/update
      if (!tb.querySelector('tr') || !currentKeys.size) {
        // first paint (fast path)
        tb.innerHTML = '';
        rows.forEach(r => {
          const tr = renderRow(r);
          tb.appendChild(tr);
          c.rowsByKey.set(r.key, r);
        });
        c.order = newKeys;
        return;
      }

      // patch pass
      rows.forEach((r, idx) => {
        const existingTr = tb.querySelector(`tr[data-key="${CSS.escape(r.key)}"]`);
        if (existingTr) {
          // compare with cache; only patch if changed
          const prev = c.rowsByKey.get(r.key);
          if (!prev ||
              prev.rank !== r.rank ||
              prev.name !== r.name ||
              String(prev.seed) !== String(r.seed) ||
              prev.wins !== r.wins ||
              prev.losses !== r.losses ||
              prev.win_pct !== r.win_pct ||
              prev.frames_for !== r.frames_for ||
              prev.frames_against !== r.frames_against ||
              prev.frame_diff !== r.frame_diff ||
              prev.eliminated !== r.eliminated ||
              prev.last_result !== r.last_result ||
              prev.last_result_at !== r.last_result_at) {
            patchRow(existingTr, r);
            c.rowsByKey.set(r.key, r);
          }
        } else {
          // new row
          const tr = renderRow(r);
          // place at correct index
          tb.insertBefore(tr, tb.children[idx] || null);
          c.rowsByKey.set(r.key, r);
        }
      });

      // 2) remove missing rows
      Array.from(tb.querySelectorAll('tr')).forEach(tr => {
        const k = tr.dataset.key;
        if (k && !newKeySet.has(k)) {
          tr.remove();
          c.rowsByKey.delete(k);
        }
      });

      // 3) order rows
      reorderRows(tid, newKeys);

    } catch (err) {
      // keep current DOM; show a small inline error only if tbody empty
      if (!tbody().children.length) {
        tbody().innerHTML = `<tr><td colspan="11" class="k" style="padding:16px;color:#fca5a5">Failed: ${esc(err.message || err)}</td></tr>`;
      }
      console.log('Ranking refresh failed:', err.message);
    }
  }

  return { refresh };
})();


/* -------------------- OPEN MODAL (LOAD DATA) -------------------- */
async function openModal(t){
  // meta header
  $('#mTitle').textContent = t.name || 'Tournament';

  // ensure Tournament tab visible by default
  $$('.tab').forEach(b=>b.classList.remove('active'));
  $$('.tab')[0].classList.add('active');
  $('#tabTournament').style.display = '';
  $('#tabRanking').style.display = 'none';

  // clear grids
  $('#wHead').innerHTML = $('#wBody').innerHTML = '';
  $('#lHead').innerHTML = $('#lBody').innerHTML = '';

  showModal();

  const modal = $('#modal');
  modal.dataset.tid = String(t.id);
  modal.dataset.format = String(t.format || 'single');
  modal.dataset.raceTo = String(t.race_to || '');
  meta.race_to = Number(modal.dataset.raceTo);

  CurrentTournamentRefresher.start(t, 5000);

  try{
    const [players, matches] = await Promise.all([listPlayers(t.id), listMatches(t.id)]);
    paintModalMeta({ format: t.format, race_to: t.race_to }, players, matches);

    const playersById = Object.fromEntries(players.map(p=>[String(p.id), p]));
    const grid = splitMatches(matches);

    // Winners
    const isDouble = String(t.format||'single').toLowerCase()==='double';

    // Winners with inline GF for double-elim
    renderWinnersWithGF($('#wHead'), $('#wBody'), grid.winners, grid.finals, playersById, isDouble);

    // Losers (double only)
    $('#losersSection').style.display = isDouble ? '' : 'none';
    if (isDouble){
      renderBracketArea($('#lHead'), $('#lBody'), grid.losers, playersById, 'L', 'space-around');
    }



    // Rankings tab content (lazy-load on open)
    renderRanking(t.id);

  }catch(e){
    console.log('Failed to load tournament view: ' + e.message);
  }
}

/* -------------------- BOOT -------------------- */
load(1)
</script>
</body>
</html>
